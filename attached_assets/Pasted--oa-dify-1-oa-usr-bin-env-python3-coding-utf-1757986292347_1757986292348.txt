æˆ‘ç°åœ¨æƒ³åšä¸€ä¸ªoaç³»ç»Ÿçš„æ–‡æ¡£ä¸‹è½½--æ¸…æ´—--å…¥åˆ°difyçŸ¥è¯†åº“çš„ä¸€ä¸ªå·¥ç¨‹
1.æˆ‘ä¼šç»™ä½ oaä¸Šæ–‡æ¡£è§£å¯†çš„æ–¹æ³•
   #!/usr/bin/env python3
# -*- coding: utf-8 -*-

import hashlib
import zipfile
import io
from pathlib import Path

def decrypt_binary_data(encrypted_data, password, output_file="decrypted.zip"):
    """
    ç›´æ¥è§£å¯†äºŒè¿›åˆ¶æ•°æ®å¹¶ä¿å­˜ä¸ºZIPæ–‡ä»¶
    
    Args:
        encrypted_data: åŠ å¯†çš„äºŒè¿›åˆ¶æ•°æ® (bytes)
        password: è§£å¯†å¯†ç  (str)
        output_file: è¾“å‡ºZIPæ–‡ä»¶è·¯å¾„ (str)
    
    Returns:
        bool: æˆåŠŸè¿”å›Trueï¼Œå¤±è´¥è¿”å›False
    """
    try:
        # å¯¼å…¥è§£å¯†åº“
        from Crypto.Cipher import AES
        from Crypto.Util.Padding import unpad
        
        print(f"ğŸ” åŸå§‹æ•°æ®å¤§å°: {len(encrypted_data)} å­—èŠ‚")
        print(f"ğŸ” æ•°æ®å¼€å¤´: {encrypted_data[:20]}")
        print(f"ğŸ”‘ ä½¿ç”¨å¯†ç : {'*' * len(password)}")
        
        # æ£€æŸ¥æ•°æ®æ˜¯å¦å·²ç»æ˜¯ZIPæ ¼å¼
        if encrypted_data.startswith(b'PK\x03\x04'):
            print("âš ï¸  æ•°æ®å¼€å¤´æ˜¯ZIPæ–‡ä»¶å¤´ï¼Œå¯èƒ½æ— éœ€è§£å¯†")
            print("ğŸ”„ å°è¯•ç›´æ¥ä¿å­˜ä¸ºZIPæ–‡ä»¶...")
            
            # ç›´æ¥ä¿å­˜
            with open(output_file, 'wb') as f:
                f.write(encrypted_data)
            
            # éªŒè¯ZIPæ–‡ä»¶
            if verify_zip_file(output_file):
                print("âœ… æ–‡ä»¶å·²ç›´æ¥è½¬æ¢ä¸ºZIPæ–‡ä»¶æˆåŠŸï¼")
                return True
            else:
                print("âŒ ç›´æ¥è½¬æ¢å¤±è´¥ï¼Œç»§ç»­å°è¯•è§£å¯†...")
        
        # ç”ŸæˆAESå¯†é’¥ (æ¨¡æ‹ŸJavaçš„æ–¹å¼)
        print("\nğŸ” å¼€å§‹AESè§£å¯†è¿‡ç¨‹...")
        key = generate_aes_key(password)
        print(f"ğŸ”‘ ç”Ÿæˆçš„å¯†é’¥: {key.hex()}")
        
        # æ£€æŸ¥æ•°æ®é•¿åº¦æ˜¯å¦ç¬¦åˆAESå—å¤§å°
        if len(encrypted_data) % 16 != 0:
            print(f"âš ï¸  æ•°æ®é•¿åº¦ {len(encrypted_data)} ä¸æ˜¯16çš„å€æ•°ï¼Œå¯èƒ½ä¸æ˜¯AESåŠ å¯†æ•°æ®")
        
        # åˆ›å»ºAESè§£å¯†å™¨ (ECBæ¨¡å¼)
        cipher = AES.new(key, AES.MODE_ECB)
        
        # æ‰§è¡Œè§£å¯†
        print("ğŸ”“ æ‰§è¡Œè§£å¯†...")
        decrypted_data = cipher.decrypt(encrypted_data)
        print(f"âœ… è§£å¯†å®Œæˆï¼Œå¾—åˆ° {len(decrypted_data)} å­—èŠ‚")
        
        # å°è¯•ç§»é™¤PKCS7å¡«å……
        try:
            unpadded_data = unpad(decrypted_data, AES.block_size)
            print(f"âœ… ç§»é™¤å¡«å……æˆåŠŸï¼Œæœ€ç»ˆæ•°æ® {len(unpadded_data)} å­—èŠ‚")
            decrypted_data = unpadded_data
        except ValueError as e:
            print(f"âš ï¸  å¡«å……ç§»é™¤å¤±è´¥: {e}")
            print("ğŸ“‹ å°è¯•ä½¿ç”¨åŸå§‹è§£å¯†æ•°æ®...")
        
        # æ£€æŸ¥è§£å¯†ç»“æœ
        print(f"ğŸ” è§£å¯†æ•°æ®å¼€å¤´: {decrypted_data[:20]}")
        
        if decrypted_data.startswith(b'PK\x03\x04'):
            print("ğŸ‰ è§£å¯†æˆåŠŸï¼æ£€æµ‹åˆ°ZIPæ–‡ä»¶å¤´")
        elif decrypted_data.startswith(b'PK\x05\x06'):
            print("ğŸ‰ è§£å¯†æˆåŠŸï¼æ£€æµ‹åˆ°ZIPæ–‡ä»¶å°¾")
        else:
            print("â“ è§£å¯†ç»“æœä¸æ˜¯æ ‡å‡†ZIPæ ¼å¼ï¼Œä½†ä»å°è¯•ä¿å­˜...")
        
        # ä¿å­˜è§£å¯†åçš„æ–‡ä»¶
        with open(output_file, 'wb') as f:
            f.write(decrypted_data)
        
        print(f"ğŸ“¦ è§£å¯†æ–‡ä»¶å·²ä¿å­˜: {output_file}")
        
        # éªŒè¯ZIPæ–‡ä»¶
        if verify_zip_file(output_file):
            print("âœ… ZIPæ–‡ä»¶éªŒè¯æˆåŠŸï¼")
            return True
        else:
            print("âŒ ZIPæ–‡ä»¶éªŒè¯å¤±è´¥ï¼Œä½†æ–‡ä»¶å·²ä¿å­˜")
            return False
            
    except ImportError:
        print("âŒ éœ€è¦å®‰è£…åŠ å¯†åº“: pip install pycryptodome")
        return False
    except Exception as e:
        print(f"âŒ è§£å¯†è¿‡ç¨‹å‡ºé”™: {e}")
        import traceback
        traceback.print_exc()
        return False

def generate_aes_key(password):
    """
    ç”ŸæˆAESå¯†é’¥ - å…¼å®¹Javaç‰ˆæœ¬
    ä½¿ç”¨SHA-256ç”Ÿæˆ128ä½å¯†é’¥
    """
    return hashlib.sha256(password.encode('utf-8')).digest()[:16]

def verify_zip_file(file_path):
    """éªŒè¯å¹¶æ˜¾ç¤ºZIPæ–‡ä»¶å†…å®¹"""
    try:
        with zipfile.ZipFile(file_path, 'r') as zip_ref:
            file_list = zip_ref.namelist()
            print(f"ğŸ“¦ ZIPåŒ…å« {len(file_list)} ä¸ªæ–‡ä»¶:")
            
            # æ˜¾ç¤ºå‰10ä¸ªæ–‡ä»¶
            for filename in file_list[:10]:
                try:
                    info = zip_ref.getinfo(filename)
                    print(f"   ğŸ“„ {filename} ({info.file_size} å­—èŠ‚)")
                except:
                    print(f"   ğŸ“„ {filename}")
            
            if len(file_list) > 10:
                print(f"   ... è¿˜æœ‰ {len(file_list) - 10} ä¸ªæ–‡ä»¶")
            
            return True
            
    except zipfile.BadZipFile as e:
        print(f"âŒ ZIPæ–‡ä»¶æ ¼å¼é”™è¯¯: {e}")
        return False
    except Exception as e:
        print(f"âŒ ZIPéªŒè¯å‡ºé”™: {e}")
        return False

   
  ä¸‹è½½å°±æ˜¯ä»å…¶s3ä¸Šä¸‹è½½å³å¯ï¼Œæˆ‘ä¼šç»™ä½ s3ç›¸å…³çš„é…ç½®åç»­ï¼Œå…è®¸é…ç½®åœ¨envç¯å¢ƒä¸­ï¼Œæ¯å¤©oaä¼šå¸æ•°åˆ°æ•°æ®æ¹–ï¼Œæˆ‘ä¼šæƒ³åŠæ³•å¢é‡åŒæ­¥åˆ°æˆ‘çš„è¡¨ä¸­ã€‚
   oaä»–ä¼šå¸æ•°çš„è¡¨ä¿¡æ¯æ˜¯class OAFileInfo(BaseModel):
    """OAç³»ç»Ÿæ–‡ä»¶ä¿¡æ¯æ¨¡å‹"""
    
    __tablename__ = "oa_file_info"
    
    # åŸºç¡€ä¿¡æ¯
    imagefileid = Column(String(100), nullable=False, unique=True, index=True, comment="æ–‡ä»¶ID")
    business_category = Column(Enum(BusinessCategory), nullable=False, comment="ä¸šåŠ¡åˆ†ç±»")
    is_zw = Column(Boolean, nullable=False, default=False, comment="æ˜¯å¦æ­£æ–‡")
    fj_imagefileid = Column(Text, comment="é™„ä»¶æ–‡ä»¶IDåˆ—è¡¨ï¼ˆJSONæ ¼å¼ï¼Œå¦‚æœæ˜¯æ­£æ–‡çš„è¯ï¼‰")
    imagefilename = Column(String(500), nullable=False, comment="æ–‡ä»¶åï¼ˆåŒ…å«åç¼€ï¼‰")
    imagefiletype = Column(String(50), comment="æ–‡æ¡£ç±»å‹")
    is_zip = Column(Boolean, default=False, comment="æ˜¯å¦å‹ç¼©æ–‡ä»¶")
    filesize = Column(Integer, comment="æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰")
    asecode = Column(String(255), comment="OSSä¸‹è½½è§£å¯†code")
    tokenkey = Column(String(500), comment="OSSä¸‹è½½key")
    
    # å¤„ç†çŠ¶æ€
    processing_status = Column(Enum(ProcessingStatus), default=ProcessingStatus.PENDING, 
                              nullable=False, comment="å¤„ç†çŠ¶æ€")
    processing_message = Column(Text, comment="å¤„ç†æ¶ˆæ¯")
    processing_started_at = Column(DateTime, comment="å¼€å§‹å¤„ç†æ—¶é—´")
    processing_completed_at = Column(DateTime, comment="å®Œæˆå¤„ç†æ—¶é—´")
    
    # å…³è”çš„Document IDï¼ˆå¤„ç†æˆåŠŸåï¼‰
    document_id = Column(Integer, comment="å…³è”çš„documentsè¡¨ID")
    
    # åŒæ­¥ä¿¡æ¯
    sync_source = Column(String(50), default="oa_system", comment="åŒæ­¥æ¥æº")
    last_sync_at = Column(DateTime, comment="æœ€ååŒæ­¥æ—¶é—´")
    
    # é”™è¯¯ä¿¡æ¯
    error_count = Column(Integer, default=0, comment="é”™è¯¯æ¬¡æ•°")
    last_error = Column(Text, comment="æœ€åé”™è¯¯ä¿¡æ¯")

    def __repr__(self):
    ç„¶åæˆ‘ä¼šå°†æ˜¯æ­£æ–‡çš„æ–‡æ¡£æ‹¿åˆ°æˆ‘çš„å¤„ç†æµç¨‹ä¸­ï¼Œåˆ¤æ–­å…¶æ ¼å¼ï¼Œæ–‡ä»¶åæ˜¯å¦åˆé€‚è¢«ä½œä¸ºçŸ¥è¯†åº“ï¼Œä¸åˆé€‚çš„æˆ‘ä¼šæ ‡è®°skipï¼Œåˆé€‚çš„æˆ‘ä¼šè¿›è¡Œä¸‹ä¸€æ­¥
2.å°†åˆé€‚çš„è¿›å…¥çš„celeryä»»åŠ¡ä¸­ä¸‹è½½è§£å¯†è§„åˆ™åˆ¤æ–­aiåˆ†æä¸è¿‡çš„åŒ–æˆ–è€…çŠ¹è±«çš„ç»™äººå·¥å®¡æ ¸ï¼Œæœ€ç»ˆè½å…¥difyçŸ¥è¯†åº“ï¼ˆè¿™å—è½åº“apiæ¥å£æ–‡æ¡£æˆ‘å…ˆä¸ç»™ä½ ä½ å…ˆtodoï¼‰
3ï¼Œé¡¹ç›®å°½å¯èƒ½å®Œå–„ï¼Œæ˜äº†æ˜“äºç†è§£ï¼Œä¹Ÿè€ƒè™‘å®‰å…¨æ€§èƒ½ç­‰è¦ç´ 
4.ä¹Ÿå¯ä»¥æä¸€ä¸ªç®€å•çš„templatesæ¥ç®€æ˜“åšä¸ªå‰ç«¯ç”¨äºå±•ç¤ºæ¯å¤©å¤„ç†çš„æ•°æ®å±•ç¤ºï¼Œäººå·¥å®¡æ‰¹ç­‰ç­‰