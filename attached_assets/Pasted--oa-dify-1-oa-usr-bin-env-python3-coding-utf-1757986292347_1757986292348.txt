我现在想做一个oa系统的文档下载--清洗--入到dify知识库的一个工程
1.我会给你oa上文档解密的方法
   #!/usr/bin/env python3
# -*- coding: utf-8 -*-

import hashlib
import zipfile
import io
from pathlib import Path

def decrypt_binary_data(encrypted_data, password, output_file="decrypted.zip"):
    """
    直接解密二进制数据并保存为ZIP文件
    
    Args:
        encrypted_data: 加密的二进制数据 (bytes)
        password: 解密密码 (str)
        output_file: 输出ZIP文件路径 (str)
    
    Returns:
        bool: 成功返回True，失败返回False
    """
    try:
        # 导入解密库
        from Crypto.Cipher import AES
        from Crypto.Util.Padding import unpad
        
        print(f"🔍 原始数据大小: {len(encrypted_data)} 字节")
        print(f"🔍 数据开头: {encrypted_data[:20]}")
        print(f"🔑 使用密码: {'*' * len(password)}")
        
        # 检查数据是否已经是ZIP格式
        if encrypted_data.startswith(b'PK\x03\x04'):
            print("⚠️  数据开头是ZIP文件头，可能无需解密")
            print("🔄 尝试直接保存为ZIP文件...")
            
            # 直接保存
            with open(output_file, 'wb') as f:
                f.write(encrypted_data)
            
            # 验证ZIP文件
            if verify_zip_file(output_file):
                print("✅ 文件已直接转换为ZIP文件成功！")
                return True
            else:
                print("❌ 直接转换失败，继续尝试解密...")
        
        # 生成AES密钥 (模拟Java的方式)
        print("\n🔐 开始AES解密过程...")
        key = generate_aes_key(password)
        print(f"🔑 生成的密钥: {key.hex()}")
        
        # 检查数据长度是否符合AES块大小
        if len(encrypted_data) % 16 != 0:
            print(f"⚠️  数据长度 {len(encrypted_data)} 不是16的倍数，可能不是AES加密数据")
        
        # 创建AES解密器 (ECB模式)
        cipher = AES.new(key, AES.MODE_ECB)
        
        # 执行解密
        print("🔓 执行解密...")
        decrypted_data = cipher.decrypt(encrypted_data)
        print(f"✅ 解密完成，得到 {len(decrypted_data)} 字节")
        
        # 尝试移除PKCS7填充
        try:
            unpadded_data = unpad(decrypted_data, AES.block_size)
            print(f"✅ 移除填充成功，最终数据 {len(unpadded_data)} 字节")
            decrypted_data = unpadded_data
        except ValueError as e:
            print(f"⚠️  填充移除失败: {e}")
            print("📋 尝试使用原始解密数据...")
        
        # 检查解密结果
        print(f"🔍 解密数据开头: {decrypted_data[:20]}")
        
        if decrypted_data.startswith(b'PK\x03\x04'):
            print("🎉 解密成功！检测到ZIP文件头")
        elif decrypted_data.startswith(b'PK\x05\x06'):
            print("🎉 解密成功！检测到ZIP文件尾")
        else:
            print("❓ 解密结果不是标准ZIP格式，但仍尝试保存...")
        
        # 保存解密后的文件
        with open(output_file, 'wb') as f:
            f.write(decrypted_data)
        
        print(f"📦 解密文件已保存: {output_file}")
        
        # 验证ZIP文件
        if verify_zip_file(output_file):
            print("✅ ZIP文件验证成功！")
            return True
        else:
            print("❌ ZIP文件验证失败，但文件已保存")
            return False
            
    except ImportError:
        print("❌ 需要安装加密库: pip install pycryptodome")
        return False
    except Exception as e:
        print(f"❌ 解密过程出错: {e}")
        import traceback
        traceback.print_exc()
        return False

def generate_aes_key(password):
    """
    生成AES密钥 - 兼容Java版本
    使用SHA-256生成128位密钥
    """
    return hashlib.sha256(password.encode('utf-8')).digest()[:16]

def verify_zip_file(file_path):
    """验证并显示ZIP文件内容"""
    try:
        with zipfile.ZipFile(file_path, 'r') as zip_ref:
            file_list = zip_ref.namelist()
            print(f"📦 ZIP包含 {len(file_list)} 个文件:")
            
            # 显示前10个文件
            for filename in file_list[:10]:
                try:
                    info = zip_ref.getinfo(filename)
                    print(f"   📄 {filename} ({info.file_size} 字节)")
                except:
                    print(f"   📄 {filename}")
            
            if len(file_list) > 10:
                print(f"   ... 还有 {len(file_list) - 10} 个文件")
            
            return True
            
    except zipfile.BadZipFile as e:
        print(f"❌ ZIP文件格式错误: {e}")
        return False
    except Exception as e:
        print(f"❌ ZIP验证出错: {e}")
        return False

   
  下载就是从其s3上下载即可，我会给你s3相关的配置后续，允许配置在env环境中，每天oa会卸数到数据湖，我会想办法增量同步到我的表中。
   oa他会卸数的表信息是class OAFileInfo(BaseModel):
    """OA系统文件信息模型"""
    
    __tablename__ = "oa_file_info"
    
    # 基础信息
    imagefileid = Column(String(100), nullable=False, unique=True, index=True, comment="文件ID")
    business_category = Column(Enum(BusinessCategory), nullable=False, comment="业务分类")
    is_zw = Column(Boolean, nullable=False, default=False, comment="是否正文")
    fj_imagefileid = Column(Text, comment="附件文件ID列表（JSON格式，如果是正文的话）")
    imagefilename = Column(String(500), nullable=False, comment="文件名（包含后缀）")
    imagefiletype = Column(String(50), comment="文档类型")
    is_zip = Column(Boolean, default=False, comment="是否压缩文件")
    filesize = Column(Integer, comment="文件大小（字节）")
    asecode = Column(String(255), comment="OSS下载解密code")
    tokenkey = Column(String(500), comment="OSS下载key")
    
    # 处理状态
    processing_status = Column(Enum(ProcessingStatus), default=ProcessingStatus.PENDING, 
                              nullable=False, comment="处理状态")
    processing_message = Column(Text, comment="处理消息")
    processing_started_at = Column(DateTime, comment="开始处理时间")
    processing_completed_at = Column(DateTime, comment="完成处理时间")
    
    # 关联的Document ID（处理成功后）
    document_id = Column(Integer, comment="关联的documents表ID")
    
    # 同步信息
    sync_source = Column(String(50), default="oa_system", comment="同步来源")
    last_sync_at = Column(DateTime, comment="最后同步时间")
    
    # 错误信息
    error_count = Column(Integer, default=0, comment="错误次数")
    last_error = Column(Text, comment="最后错误信息")

    def __repr__(self):
    然后我会将是正文的文档拿到我的处理流程中，判断其格式，文件名是否合适被作为知识库，不合适的我会标记skip，合适的我会进行下一步
2.将合适的进入的celery任务中下载解密规则判断ai分析不过的化或者犹豫的给人工审核，最终落入dify知识库（这块落库api接口文档我先不给你你先todo）
3，项目尽可能完善，明了易于理解，也考虑安全性能等要素
4.也可以搞一个简单的templates来简易做个前端用于展示每天处理的数据展示，人工审批等等